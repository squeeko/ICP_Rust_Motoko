{"version":3,"file":"secp256k1.js","sourceRoot":"","sources":["../../src/secp256k1.ts"],"names":[],"mappings":"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","sourcesContent":["/* eslint-disable no-underscore-dangle */\nimport {\n  DerEncodedPublicKey,\n  KeyPair,\n  Signature,\n  uint8ToBuf,\n  bufFromBufLike,\n  fromHex,\n  toHex,\n} from '@dfinity/agent';\nimport { secp256k1 } from '@noble/curves/secp256k1';\nimport { sha256 } from '@noble/hashes/sha256';\nimport { randomBytes } from '@noble/hashes/utils';\nimport hdkey from 'hdkey';\nimport { mnemonicToSeedSync } from 'bip39';\nimport { PublicKey, SignIdentity } from '@dfinity/agent';\nimport { SECP256K1_OID, unwrapDER, wrapDER } from './der';\nimport { pemToSecretKey } from './pem';\n\ndeclare type PublicKeyHex = string;\ndeclare type SecretKeyHex = string;\nexport declare type JsonableSecp256k1Identity = [PublicKeyHex, SecretKeyHex];\n\ndeclare type KeyLike = PublicKey | DerEncodedPublicKey | ArrayBuffer | ArrayBufferView;\n\nfunction isObject(value: unknown) {\n  return value !== null && typeof value === 'object';\n}\n\nexport class Secp256k1PublicKey implements PublicKey {\n  public static fromRaw(rawKey: ArrayBuffer): Secp256k1PublicKey {\n    return new Secp256k1PublicKey(bufFromBufLike(rawKey));\n  }\n\n  public static fromDer(derKey: DerEncodedPublicKey): Secp256k1PublicKey {\n    return new Secp256k1PublicKey(this.derDecode(derKey));\n  }\n\n  /**\n   * Construct Secp256k1PublicKey from an existing PublicKey\n   * @param {unknown} maybeKey - existing PublicKey, ArrayBuffer, DerEncodedPublicKey, or hex string\n   * @returns {Secp256k1PublicKey} Instance of Secp256k1PublicKey\n   */\n  public static from(maybeKey: unknown): Secp256k1PublicKey {\n    if (typeof maybeKey === 'string') {\n      const key = fromHex(maybeKey);\n      return this.fromRaw(key);\n    } else if (isObject(maybeKey)) {\n      const key = maybeKey as KeyLike;\n      if (isObject(key) && Object.hasOwnProperty.call(key, '__derEncodedPublicKey__')) {\n        return this.fromDer(key as DerEncodedPublicKey);\n      } else if (ArrayBuffer.isView(key)) {\n        const view = key as ArrayBufferView;\n        return this.fromRaw(bufFromBufLike(view.buffer));\n      } else if (key instanceof ArrayBuffer) {\n        return this.fromRaw(key);\n      } else if ('rawKey' in key) {\n        return this.fromRaw(key.rawKey as ArrayBuffer);\n      } else if ('derKey' in key) {\n        return this.fromDer(key.derKey as DerEncodedPublicKey);\n      } else if ('toDer' in key) {\n        return this.fromDer(key.toDer() as ArrayBuffer);\n      }\n    }\n    throw new Error('Cannot construct Secp256k1PublicKey from the provided key.');\n  }\n\n  private static derEncode(publicKey: ArrayBuffer): DerEncodedPublicKey {\n    const key = bufFromBufLike(wrapDER(publicKey, SECP256K1_OID).buffer) as DerEncodedPublicKey;\n    key.__derEncodedPublicKey__ = undefined;\n    return key;\n  }\n\n  private static derDecode(key: DerEncodedPublicKey): ArrayBuffer {\n    return unwrapDER(key, SECP256K1_OID);\n  }\n\n  #rawKey: ArrayBuffer;\n\n  public get rawKey(): ArrayBuffer {\n    return this.#rawKey;\n  }\n\n  #derKey: DerEncodedPublicKey;\n\n  public get derKey(): DerEncodedPublicKey {\n    return this.#derKey;\n  }\n\n  // `fromRaw` and `fromDer` should be used for instantiation, not this constructor.\n  private constructor(key: ArrayBuffer) {\n    this.#rawKey = bufFromBufLike(key);\n    this.#derKey = Secp256k1PublicKey.derEncode(key);\n  }\n\n  public toDer(): DerEncodedPublicKey {\n    return this.derKey;\n  }\n\n  public toRaw(): ArrayBuffer {\n    return this.rawKey;\n  }\n}\n\nexport class Secp256k1KeyIdentity extends SignIdentity {\n  /**\n   * Generates an identity. If a seed is provided, the keys are generated from the\n   * seed according to BIP 0032. Otherwise, the key pair is randomly generated.\n   * This method throws an error in case the seed is not 32 bytes long or invalid\n   * for use as a private key.\n   * @param {Uint8Array} seed the optional seed\n   * @returns {Secp256k1KeyIdentity}\n   */\n  public static generate(seed?: Uint8Array): Secp256k1KeyIdentity {\n    if (seed && seed.byteLength !== 32) {\n      throw new Error('Secp256k1 Seed needs to be 32 bytes long.');\n    }\n    let privateKey: Uint8Array;\n\n    if (seed) {\n      // private key from seed according to https://en.bitcoin.it/wiki/BIP_0032\n      // master key generation:\n      privateKey = seed;\n      if (!secp256k1.utils.isValidPrivateKey(privateKey)) {\n        throw new Error('The seed is invalid.');\n      }\n    } else {\n      privateKey = new Uint8Array(randomBytes(32));\n      while (!secp256k1.utils.isValidPrivateKey(privateKey)) {\n        privateKey = new Uint8Array(randomBytes(32));\n      }\n    }\n\n    const publicKeyRaw = secp256k1.getPublicKey(privateKey, false);\n\n    const publicKey = Secp256k1PublicKey.fromRaw(publicKeyRaw);\n    return new this(publicKey, privateKey);\n  }\n\n  public static fromParsedJson(obj: JsonableSecp256k1Identity): Secp256k1KeyIdentity {\n    const [publicKeyRaw, privateKeyRaw] = obj;\n    return new Secp256k1KeyIdentity(\n      Secp256k1PublicKey.fromRaw(fromHex(publicKeyRaw)),\n      fromHex(privateKeyRaw),\n    );\n  }\n\n  public static fromJSON(json: string): Secp256k1KeyIdentity {\n    const parsed = JSON.parse(json);\n    if (Array.isArray(parsed)) {\n      if (typeof parsed[0] === 'string' && typeof parsed[1] === 'string') {\n        return this.fromParsedJson([parsed[0], parsed[1]]);\n      }\n      throw new Error('Deserialization error: JSON must have at least 2 items.');\n    }\n    throw new Error(`Deserialization error: Invalid JSON type for string: ${JSON.stringify(json)}`);\n  }\n\n  /**\n   * generates an identity from a public and private key. Please ensure that you are generating these keys securely and protect the user's private key\n   * @param {ArrayBuffer} publicKey\n   * @param {ArrayBuffer} privateKey\n   * @returns {Secp256k1KeyIdentity}\n   */\n  public static fromKeyPair(publicKey: ArrayBuffer, privateKey: ArrayBuffer): Secp256k1KeyIdentity {\n    return new Secp256k1KeyIdentity(Secp256k1PublicKey.fromRaw(publicKey), privateKey);\n  }\n\n  /**\n   * generates an identity from an existing secret key, and is the correct method to generate an identity from a seed phrase. Please ensure you protect the user's private key.\n   * @param {ArrayBuffer} secretKey\n   * @returns {Secp256k1KeyIdentity}\n   */\n  public static fromSecretKey(secretKey: ArrayBuffer): Secp256k1KeyIdentity {\n    const publicKey = secp256k1.getPublicKey(new Uint8Array(secretKey), false);\n    const identity = Secp256k1KeyIdentity.fromKeyPair(publicKey, new Uint8Array(secretKey));\n    return identity;\n  }\n\n  /**\n   * Generates an identity from a seed phrase. Use carefully - seed phrases should only be used in secure contexts, and you should avoid having users copying and pasting seed phrases as much as possible.\n   * @param {string | string[]} seedPhrase - either an array of words or a string of words separated by spaces.\n   * @param password - optional password to be used by bip39\n   * @returns Secp256k1KeyIdentity\n   */\n  public static fromSeedPhrase(\n    seedPhrase: string | string[],\n    password?: string | undefined,\n  ): Secp256k1KeyIdentity {\n    // Convert to string for convenience\n    const phrase = Array.isArray(seedPhrase) ? seedPhrase.join(' ') : seedPhrase;\n    // Warn if provided phrase is not conventional\n    if (phrase.split(' ').length < 12 || phrase.split(' ').length > 24) {\n      console.warn(\n        'Warning - an unusually formatted seed phrase has been provided. Decoding may not work as expected',\n      );\n    }\n\n    const seed = mnemonicToSeedSync(phrase, password);\n    const root = hdkey.fromMasterSeed(seed);\n    const addrnode = root.derive(\"m/44'/223'/0'/0/0\");\n\n    return Secp256k1KeyIdentity.fromSecretKey(addrnode.privateKey);\n  }\n\n  /**\n   * Utility method to create a Secp256k1KeyIdentity from a PEM-encoded key.\n   * @param pemKey - PEM-encoded key as a string\n   * @returns - Secp256k1KeyIdentity\n   */\n  public static fromPem(pemKey: string): Secp256k1KeyIdentity {\n    const secretKey = pemToSecretKey(pemKey);\n    return this.fromSecretKey(secretKey);\n  }\n\n  _publicKey: Secp256k1PublicKey;\n\n  protected constructor(publicKey: Secp256k1PublicKey, protected _privateKey: ArrayBuffer) {\n    super();\n    this._publicKey = publicKey;\n  }\n\n  /**\n   * Serialize this key to JSON-serializable object.\n   * @returns {JsonableSecp256k1Identity}\n   */\n  public toJSON(): JsonableSecp256k1Identity {\n    return [toHex(this._publicKey.toRaw()), toHex(this._privateKey)];\n  }\n\n  /**\n   * Return a copy of the key pair.\n   * @returns {KeyPair}\n   */\n  public getKeyPair(): KeyPair {\n    return {\n      secretKey: this._privateKey,\n      publicKey: this._publicKey,\n    };\n  }\n\n  /**\n   * Return the public key.\n   * @returns {Required<PublicKey>}\n   */\n  public getPublicKey(): Required<PublicKey> {\n    return this._publicKey;\n  }\n\n  /**\n   * Signs a blob of data, with this identity's private key.\n   * @param {ArrayBuffer} challenge - challenge to sign with this identity's secretKey, producing a signature\n   * @returns {Promise<Signature>} signature\n   */\n  public async sign(challenge: ArrayBuffer): Promise<Signature> {\n    const hash = sha256.create();\n    hash.update(new Uint8Array(challenge));\n    const signature = uint8ToBuf(\n      secp256k1\n        .sign(new Uint8Array(hash.digest()), new Uint8Array(this._privateKey))\n        .toCompactRawBytes(),\n    );\n    return signature as Signature;\n  }\n}\n\nexport default Secp256k1KeyIdentity;\n"]}