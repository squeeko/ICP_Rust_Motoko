{
  "version": 3,
  "sources": ["../../src/utils/neurons.utils.ts"],
  "sourcesContent": ["import type { Vote } from \"../enums/governance.enums\";\nimport type {\n  Ballot,\n  BallotInfo,\n  NeuronInfo,\n  ProposalId,\n  ProposalInfo,\n} from \"../types/governance_converters\";\n\nconst voteForProposal = ({\n  recentBallots,\n  proposalId,\n}: {\n  recentBallots: BallotInfo[];\n  proposalId: ProposalId | undefined;\n}): Vote | undefined => {\n  if (!proposalId) {\n    return undefined;\n  }\n\n  const ballot: BallotInfo | undefined = recentBallots.find(\n    ({ proposalId: id }: BallotInfo) => id === proposalId,\n  );\n  return ballot?.vote;\n};\n\n/**\n * Filter the neurons that are ineligible to vote to a proposal.\n *\n * This feature needs the ballots of the proposal to contains accurate data.\n * If the proposal has settled, as the ballots of the proposal are emptied for archive purpose, the function might return a list of ineligible neurons that are actually neurons that have not voted but would have been eligible.\n *\n * Long story short, check the status of the proposal before using this function.\n *\n * @param {neurons; proposal;} params\n * @param params.neurons The neurons to filter.\n * @param params.proposal The proposal to match against the selected neurons.\n */\nexport const ineligibleNeurons = ({\n  neurons,\n  proposal,\n}: {\n  neurons: NeuronInfo[];\n  proposal: ProposalInfo;\n}): NeuronInfo[] => {\n  const { ballots, proposalTimestampSeconds } = proposal;\n\n  return neurons.filter(({ createdTimestampSeconds, neuronId }: NeuronInfo) => {\n    const createdSinceProposal: boolean =\n      createdTimestampSeconds > proposalTimestampSeconds;\n\n    const dissolveTooShort: boolean =\n      ballots.find(\n        ({ neuronId: ballotNeuronId }: Ballot) => ballotNeuronId === neuronId,\n      ) === undefined;\n\n    return createdSinceProposal || dissolveTooShort;\n  });\n};\n\n/**\n * Filter the neurons that can vote for a proposal - i.e. the neurons that have not voted yet and are eligible\n *\n * @param {neurons; proposal;} params\n * @param params.neurons The neurons to filter.\n * @param params.proposal The proposal to match against the selected neurons.\n */\nexport const votableNeurons = ({\n  neurons,\n  proposal,\n}: {\n  neurons: NeuronInfo[];\n  proposal: ProposalInfo;\n}): NeuronInfo[] => {\n  const { id: proposalId } = proposal;\n\n  return neurons.filter(\n    ({ recentBallots, neuronId }: NeuronInfo) =>\n      voteForProposal({ recentBallots, proposalId }) === undefined &&\n      ineligibleNeurons({ neurons, proposal }).find(\n        ({ neuronId: ineligibleNeuronId }: NeuronInfo) =>\n          ineligibleNeuronId === neuronId,\n      ) === undefined,\n  );\n};\n\n/**\n * Filter the neurons that have voted for a proposal.\n *\n * @param {neurons; proposal;} params\n * @param params.neurons The neurons to filter.\n * @param params.proposal The proposal for which some neurons might have already voted.\n */\nexport const votedNeurons = ({\n  neurons,\n  proposal: { id: proposalId },\n}: {\n  neurons: NeuronInfo[];\n  proposal: ProposalInfo;\n}): NeuronInfo[] =>\n  neurons.filter(\n    ({ recentBallots }: NeuronInfo) =>\n      voteForProposal({ recentBallots, proposalId }) !== undefined,\n  );\n"],
  "mappings": "oiBASA,IAAMA,EAAkB,CAAC,CACvB,cAAAC,EACA,WAAAC,CACF,IAIOA,EAIkCD,EAAc,KACnD,CAAC,CAAE,WAAYE,CAAG,IAAkBA,IAAOD,CAC7C,GACe,KANb,OAqBSE,EAAoB,CAAC,CAChC,QAAAC,EACA,SAAAC,CACF,IAGoB,CAClB,GAAM,CAAE,QAAAC,EAAS,yBAAAC,CAAyB,EAAIF,EAE9C,OAAOD,EAAQ,OAAO,CAAC,CAAE,wBAAAI,EAAyB,SAAAC,CAAS,IAAkB,CAC3E,IAAMC,EACJF,EAA0BD,EAEtBI,EACJL,EAAQ,KACN,CAAC,CAAE,SAAUM,CAAe,IAAcA,IAAmBH,CAC/D,IAAM,OAER,OAAOC,GAAwBC,CACjC,CAAC,CACH,EASaE,EAAiB,CAAC,CAC7B,QAAAT,EACA,SAAAC,CACF,IAGoB,CAClB,GAAM,CAAE,GAAIJ,CAAW,EAAII,EAE3B,OAAOD,EAAQ,OACb,CAAC,CAAE,cAAAJ,EAAe,SAAAS,CAAS,IACzBV,EAAgB,CAAE,cAAAC,EAAe,WAAAC,CAAW,CAAC,IAAM,QACnDE,EAAkB,CAAE,QAAAC,EAAS,SAAAC,CAAS,CAAC,EAAE,KACvC,CAAC,CAAE,SAAUS,CAAmB,IAC9BA,IAAuBL,CAC3B,IAAM,MACV,CACF,EASaM,EAAe,CAAC,CAC3B,QAAAX,EACA,SAAU,CAAE,GAAIH,CAAW,CAC7B,IAIEG,EAAQ,OACN,CAAC,CAAE,cAAAJ,CAAc,IACfD,EAAgB,CAAE,cAAAC,EAAe,WAAAC,CAAW,CAAC,IAAM,MACvD",
  "names": ["voteForProposal", "recentBallots", "proposalId", "id", "ineligibleNeurons", "neurons", "proposal", "ballots", "proposalTimestampSeconds", "createdTimestampSeconds", "neuronId", "createdSinceProposal", "dissolveTooShort", "ballotNeuronId", "votableNeurons", "ineligibleNeuronId", "votedNeurons"]
}
