{
  "version": 3,
  "sources": ["../../src/types/ledger.responses.ts", "../../src/utils/ledger.utils.ts", "../../src/utils/payment.utils.ts"],
  "sourcesContent": ["import type { Principal } from \"@dfinity/principal\";\nimport type { Subaccount, Value } from \"../../candid/icrc1_ledger\";\n\n// Source: https://github.com/dfinity/icrc-1#standard-metadata-entries\nexport enum IcrcMetadataResponseEntries {\n  SYMBOL = \"icrc1:symbol\",\n  NAME = \"icrc1:name\",\n  DECIMALS = \"icrc1:decimals\",\n  FEE = \"icrc1:fee\",\n  LOGO = \"icrc1:logo\",\n}\n\nexport type IcrcTokenMetadataResponse = [\n  string | IcrcMetadataResponseEntries,\n  Value,\n][];\n\nexport interface IcrcAccount {\n  owner: Principal;\n  subaccount?: Subaccount;\n}\n", "import { Principal } from \"@dfinity/principal\";\nimport {\n  bigEndianCrc32,\n  encodeBase32,\n  hexStringToUint8Array,\n  isNullish,\n  notEmptyString,\n  uint8ArrayToHexString,\n} from \"@dfinity/utils\";\nimport type { IcrcAccount } from \"../types/ledger.responses\";\n\nconst MAX_SUBACCOUNT_HEX_LENGTH = 64;\n\n/**\n * Encodes an Icrc-1 account compatible into a string.\n * Formatting Reference: https://github.com/dfinity/ICRC-1/blob/main/standards/ICRC-1/TextualEncoding.md\n *\n * @param account { owner: Principal, subaccount?: Uint8Array }\n * @returns string\n */\nexport const encodeIcrcAccount = ({\n  owner,\n  subaccount,\n}: IcrcAccount): string => {\n  if (isNullish(subaccount)) {\n    return owner.toText();\n  }\n\n  const removeLeadingZeros = (text: string): string => text.replace(/^0+/, \"\");\n\n  const subaccountText = removeLeadingZeros(uint8ArrayToHexString(subaccount));\n\n  if (subaccountText.length === 0) {\n    return owner.toText();\n  }\n\n  return `${owner.toText()}-${encodeCrc({\n    owner,\n    subaccount,\n  })}.${subaccountText}`;\n};\n\nconst encodeCrc = ({ owner, subaccount }: Required<IcrcAccount>): string => {\n  const crc = bigEndianCrc32(\n    Uint8Array.from([...owner.toUint8Array(), ...subaccount]),\n  );\n\n  return encodeBase32(crc);\n};\n\n/**\n * Decodes a string into an Icrc-1 compatible account.\n * Formatting Reference: https://github.com/dfinity/ICRC-1/blob/main/standards/ICRC-1/TextualEncoding.md\n *\n * @param accountString string\n * @throws Error if the string is not a valid Icrc-1 account\n * @returns IcrcAccount { owner: Principal, subaccount?: Uint8Array }\n */\nexport const decodeIcrcAccount = (accountString: string): IcrcAccount => {\n  const [principalAndMaybeCheckSum, subaccountHex] = accountString.split(\".\");\n\n  if (!notEmptyString(principalAndMaybeCheckSum)) {\n    throw new Error(\"Invalid account. No string provided.\");\n  }\n\n  if (isNullish(subaccountHex)) {\n    return {\n      owner: Principal.fromText(accountString),\n    };\n  }\n\n  const [checksum, ...rest] = principalAndMaybeCheckSum.split(\"-\").reverse();\n  const principalText = rest.reverse().join(\"-\");\n\n  const account = {\n    owner: Principal.fromText(principalText),\n    subaccount: hexStringToUint8Array(\n      subaccountHex.padStart(MAX_SUBACCOUNT_HEX_LENGTH, \"0\"),\n    ),\n  };\n\n  const crcText = encodeCrc(account);\n\n  if (crcText !== checksum) {\n    throw new Error(\"Invalid account. Invalid checksum.\");\n  }\n\n  return account;\n};\n", "import { isNullish, nonNullish } from \"@dfinity/utils\";\n\n/**\n * \uD83D\uDC40 This feature is currently in draft. You can find more information about it at https://github.com/dfinity/ICRC/issues/22.\n *\n * A naive implementation of a payment parser. Given a code, the function attempts to extract a token name, account identifier (textual representation), and an optional amount.\n *\n * If the code doesn't match the expected pattern, `undefined` is returned for simplicity.\n * Similarly, if an optional amount is provided but it's not a valid number, the parser will not throw an exception and returns `undefined`.\n *\n * Please note that this function doesn't perform any validity checks on the extracted information.\n * It does not verify if the token is known or if the identifier is a valid address.\n *\n * ```\n * urn            = token \":\" address [ \"?\" params]\n * token         = [ ckbtc / icp / chat / bitcoin / ethereum ... ]\n * address       = STRING\n * params        = param [ \"&\" params ]\n * param         = [ amountparam ]\n * amountparam   = \"amount=\" *digit [ \".\" *digit ]\n * ```\n *\n * @param code string\n * @returns { token: string; identifier: string; amount?: number } | undefined\n */\nexport const decodePayment = (\n  code: string,\n): { token: string; identifier: string; amount?: number } | undefined => {\n  const regex =\n    /^([a-zA-Z]+):([A-Za-z0-9:\\-.]+).*?(?:[?&](?:amount|value)=(\\d+(?:\\.\\d+)?))?$/;\n\n  const match = code.match(regex);\n  if (isNullish(match)) {\n    return undefined;\n  }\n\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  const [_, token, identifier, amount] = match;\n\n  return {\n    token,\n    identifier,\n    ...(nonNullish(amount) &&\n      !isNaN(parseFloat(amount)) && { amount: parseFloat(amount) }),\n  };\n};\n"],
  "mappings": "8FAIO,IAAKA,OACVA,EAAA,OAAS,eACTA,EAAA,KAAO,aACPA,EAAA,SAAW,iBACXA,EAAA,IAAM,YACNA,EAAA,KAAO,aALGA,OAAA,ICJZ,OAAS,aAAAC,MAAiB,qBAC1B,OACE,kBAAAC,EACA,gBAAAC,EACA,yBAAAC,EACA,aAAAC,EACA,kBAAAC,EACA,yBAAAC,MACK,iBAGP,IAAMC,EAA4B,GASrBC,EAAoB,CAAC,CAChC,MAAAC,EACA,WAAAC,CACF,IAA2B,CACzB,GAAIN,EAAUM,CAAU,EACtB,OAAOD,EAAM,OAAO,EAKtB,IAAME,GAFsBC,GAAyBA,EAAK,QAAQ,MAAO,EAAE,GAEjCN,EAAsBI,CAAU,CAAC,EAE3E,OAAIC,EAAe,SAAW,EACrBF,EAAM,OAAO,EAGf,GAAGA,EAAM,OAAO,KAAKI,EAAU,CACpC,MAAAJ,EACA,WAAAC,CACF,CAAC,KAAKC,GACR,EAEME,EAAY,CAAC,CAAE,MAAAJ,EAAO,WAAAC,CAAW,IAAqC,CAC1E,IAAMI,EAAMb,EACV,WAAW,KAAK,CAAC,GAAGQ,EAAM,aAAa,EAAG,GAAGC,CAAU,CAAC,CAC1D,EAEA,OAAOR,EAAaY,CAAG,CACzB,EAUaC,EAAqBC,GAAuC,CACvE,GAAM,CAACC,EAA2BC,CAAa,EAAIF,EAAc,MAAM,GAAG,EAE1E,GAAI,CAACX,EAAeY,CAAyB,EAC3C,MAAM,IAAI,MAAM,sCAAsC,EAGxD,GAAIb,EAAUc,CAAa,EACzB,MAAO,CACL,MAAOlB,EAAU,SAASgB,CAAa,CACzC,EAGF,GAAM,CAACG,EAAU,GAAGC,CAAI,EAAIH,EAA0B,MAAM,GAAG,EAAE,QAAQ,EACnEI,EAAgBD,EAAK,QAAQ,EAAE,KAAK,GAAG,EAEvCE,EAAU,CACd,MAAOtB,EAAU,SAASqB,CAAa,EACvC,WAAYlB,EACVe,EAAc,SAASX,EAA2B,GAAG,CACvD,CACF,EAIA,GAFgBM,EAAUS,CAAO,IAEjBH,EACd,MAAM,IAAI,MAAM,oCAAoC,EAGtD,OAAOG,CACT,ECxFA,OAAS,aAAAC,EAAW,cAAAC,MAAkB,iBAyB/B,IAAMC,EACXC,GACuE,CACvE,IAAMC,EACJ,+EAEIC,EAAQF,EAAK,MAAMC,CAAK,EAC9B,GAAIJ,EAAUK,CAAK,EACjB,OAIF,GAAM,CAACC,EAAGC,EAAOC,EAAYC,CAAM,EAAIJ,EAEvC,MAAO,CACL,MAAAE,EACA,WAAAC,EACA,GAAIP,EAAWQ,CAAM,GACnB,CAAC,MAAM,WAAWA,CAAM,CAAC,GAAK,CAAE,OAAQ,WAAWA,CAAM,CAAE,CAC/D,CACF",
  "names": ["IcrcMetadataResponseEntries", "Principal", "bigEndianCrc32", "encodeBase32", "hexStringToUint8Array", "isNullish", "notEmptyString", "uint8ArrayToHexString", "MAX_SUBACCOUNT_HEX_LENGTH", "encodeIcrcAccount", "owner", "subaccount", "subaccountText", "text", "encodeCrc", "crc", "decodeIcrcAccount", "accountString", "principalAndMaybeCheckSum", "subaccountHex", "checksum", "rest", "principalText", "account", "isNullish", "nonNullish", "decodePayment", "code", "regex", "match", "_", "token", "identifier", "amount"]
}
