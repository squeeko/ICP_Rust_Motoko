import{Canister as T,createServices as R}from"@dfinity/utils";var _=({IDL:t})=>{let e=t.Record({ledger_id:t.Principal}),c=t.Nat,r=t.Record({owner:t.Principal,subaccount:t.Opt(t.Vec(t.Nat8))}),n=t.Record({max_results:t.Nat,start:t.Opt(c),account:r}),i=t.Record({burn:t.Opt(t.Record({from:r,memo:t.Opt(t.Vec(t.Nat8)),created_at_time:t.Opt(t.Nat64),amount:t.Nat})),kind:t.Text,mint:t.Opt(t.Record({to:r,memo:t.Opt(t.Vec(t.Nat8)),created_at_time:t.Opt(t.Nat64),amount:t.Nat})),timestamp:t.Nat64,transfer:t.Opt(t.Record({to:r,fee:t.Opt(t.Nat),from:r,memo:t.Opt(t.Vec(t.Nat8)),created_at_time:t.Opt(t.Nat64),amount:t.Nat}))}),d=t.Record({id:c,transaction:i}),p=t.Record({transactions:t.Vec(d),oldest_tx_id:t.Opt(c)}),m=t.Record({message:t.Text}),u=t.Variant({Ok:p,Err:m}),o=t.Vec(t.Nat8),l=t.Record({owner:t.Principal,start:t.Opt(o)});return t.Service({get_account_transactions:t.Func([n],[u],[]),ledger_id:t.Func([],[t.Principal],[]),list_subaccounts:t.Func([l],[t.Vec(o)],[])})};var O=({IDL:t})=>{let e=t.Record({ledger_id:t.Principal}),c=t.Nat,r=t.Record({owner:t.Principal,subaccount:t.Opt(t.Vec(t.Nat8))}),n=t.Record({max_results:t.Nat,start:t.Opt(c),account:r}),i=t.Record({burn:t.Opt(t.Record({from:r,memo:t.Opt(t.Vec(t.Nat8)),created_at_time:t.Opt(t.Nat64),amount:t.Nat})),kind:t.Text,mint:t.Opt(t.Record({to:r,memo:t.Opt(t.Vec(t.Nat8)),created_at_time:t.Opt(t.Nat64),amount:t.Nat})),timestamp:t.Nat64,transfer:t.Opt(t.Record({to:r,fee:t.Opt(t.Nat),from:r,memo:t.Opt(t.Vec(t.Nat8)),created_at_time:t.Opt(t.Nat64),amount:t.Nat}))}),d=t.Record({id:c,transaction:i}),p=t.Record({transactions:t.Vec(d),oldest_tx_id:t.Opt(c)}),m=t.Record({message:t.Text}),u=t.Variant({Ok:p,Err:m}),o=t.Vec(t.Nat8),l=t.Record({owner:t.Principal,start:t.Opt(o)});return t.Service({get_account_transactions:t.Func([n],[u],[]),ledger_id:t.Func([],[t.Principal],["query"]),list_subaccounts:t.Func([l],[t.Vec(o)],["query"])})};import{toNullable as A}from"@dfinity/utils";var g=({owner:t,subaccount:e})=>({owner:t,subaccount:A(e)}),N=({account:t,max_results:e,start:c})=>({account:g(t),max_results:e,start:A(c)});var a=class extends Error{};var s=class extends T{static create(e){let{service:c,certifiedService:r,canisterId:n}=R({options:e,idlFactory:O,certifiedIdlFactory:_});return new s(n,c,r)}getTransactions=async e=>{let c=await this.caller({certified:!0}).get_account_transactions(N(e));if("Err"in c)throw new a(c.Err.message);return c.Ok}};export{a,s as b};
//# sourceMappingURL=chunk-7ES7GLUU.js.map
